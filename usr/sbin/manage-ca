#!/bin/bash

# Licensed under MIT License. Use at your own risk.
#
# References:
#  https://jamielinux.com/docs/openssl-certificate-authority/index.html
#  https://github.com/chilladx/config-parser

############################################################
# Setup                                                    #
############################################################
shopt -s nocasematch
version="0.1"
configfile="/etc/ca-manager/ca-manager.conf"

interrupt_c() {
	echo CTRL-C Pressed!!
}

interrupt_other() {
	another interrupt was done. Exiting.
	exit
}

exit_cmd() {
	echo Finished.
	exit
}

trap exit_cmd EXIT
trap interrupt_c SIGINT
trap interrupt_other SIGHUP SIGTERM

############################################################
# Help Functions                                           #
############################################################

help_main() {
	echo ""
	echo "Usage: $0 [options] <COMMAND>"
	echo "	COMMAND: list, new, config, help, sign, export, import"
	echo "	Use help <COMMAND> to find help"
}

help_funct() {
	echo "CA Key Manager $version Help"
	if `type help_funct_$1 &> /dev/null`; then
		help_funct_$1
	elif [[ $1 == "" ]]; then
		help_main
	elif [[ $1 == "-h" || $1 == "--help" ]]; then
		help_funct_help
	else
		echo "Command not found. Either help has not been written for that command or it doesn't exist"
	fi
}

help_funct_help() {
	echo "Help for when you need help:"
	echo "Well, there really isn't any help for you if you need to find out how to use the help function"
	echo "Just put a command name after help to figure out what it does."
}

help_funct_list() {
	echo "The List Command:"
}
help_funct_config() {
	echo "The Config Command:"
}

############################################################
# Config                                                   #
############################################################

generate_ssl_config() {
# TODO: Finish openssl.cnf generation (with option to create the main CA or an intermediate CA)
if [[ $1 == "root" ]]; then
	policy="policy_strict"
else
	policy="policy_loose"
fi
cat <<-EOFILE
	[ ca ]
	default_ca	= CA_default		# The default ca section
	
	[ CA_default ]
	dir	              = $directory/$target
	certs	          = \$dir/certs
	crl_dir	          = \$dir/crl
	database          = \$dir/index.txt
	new_certs_dir     = \$dir/newcerts
	certificate	      = \$dir/certs/$target.cert.pem 
	serial		      = \$dir/serial 	
	private_key	      = \$dir/private/$target.key.pem# The private key
	RANDFILE	      = \$dir/private/.rand
	
	# Certificat Revocation Lists
	crl_extensions    = crl_ext
	crlnumber	      = \$dir/crlnumber
	crl		          = \$dir/$target.crl.pem
	default_crl_days  = 30
	
	# Encoding
	default_md        = sha512
	
	name_opt          = ca_default
	cert_opt          = ca_default
	default_days      = 375
	preserve          = no
	policy            = $policy
	
	[ policy_strict ]
	# For root CA
	countryName            = match
	stateOrProvinceName    = match
	organizationName       = match
	organizationalUnitName = optional
	commonName             = supplied
	emailAddress           = optional
	
	[ policy_loose ]
	# For intermediate CA's
	countryName            = optional
	stateOrProvinceName    = optional
	localityName           = optional
	organizationName       = optional
	organizationalUnitName = optional
	commonName             = supplied
	emailAddress           = optional
	
	[ req ]
	# Options for the req tool
	default_bits           = 2048
	distinguished_name     = req_distinguished_name
	string_mask            = utf8only
	default_md             = sha512
	x509_extensions        = v3_ca
	
	[ req_distinguished_name ]
	countryName                     = Country Name (2 letter code)
	stateOrProvinceName             = State or Province Name
	localityName                    = Locality Name
	0.organizationName              = Organization Name
	organizationalUnitName          = Organizational Unit Name
	commonName                      = Common Name
	emailAddress                    = Email Address (Leave Empty)
	
	# Defaults
	countryName_default             = US
	stateOrProvinceName_default     = Florida
	localityName_default            = Pensacola
	0.organizationName_default      = $companyName
	
	[ v3_ca ]
	# Extensions for the CA
	subjectKeyIdentifier    = hash
	authorityKeyIdentifier  = keyid:always,issuer
	basicConstraints        = critical, CA:true, pathlen:1
	keyUsage                = critical, digitalSignature, cRLSign, keyCertSign
	
	[ v3_intermediate_ca ]
	subjectKeyIdentifier    = hash
	authorityKeyIdentifier  = keyid:always,issuer
	basicConstraints        = critical, CA:true, pathlen:0
	keyUsage                = critical, digitalSignature, cRLSign, keyCertSign
	
	[ usr_cert ]
	# Extensions for client certificates (`man x509v3_config`).
	basicConstraints = CA:FALSE
	nsCertType = client, email
	nsComment = "OpenSSL Generated Client Certificate"
	subjectKeyIdentifier = hash
	authorityKeyIdentifier = keyid,issuer
	keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
	extendedKeyUsage = clientAuth, emailProtection
	
	[ server_cert ]
	# Extensions for server certificates (`man x509v3_config`).
	basicConstraints = CA:FALSE
	nsCertType = server
	nsComment = "OpenSSL Generated Server Certificate"
	subjectKeyIdentifier = hash
	authorityKeyIdentifier = keyid,issuer:always
	keyUsage = critical, digitalSignature, keyEncipherment
	extendedKeyUsage = serverAuth
	
	[ crl_ext ]
	authorityKeyIdentifier = keyid:always
	
	[ ocsp ]
	basicConstraints = CA:FALSE
	subjectKeyIdentifier = hash
	authorityKeyIdentifier = keyid,issuer
	keyUsage = critical, digitalSignature
	extendedKeyUsage = critical, OCSPSigning
EOFILE
}

modify_ssl_config() {
	echo Changing ssl config
	if ! [ -e "$1" ]; then
		echo "ERROR: SSL Config file does not exist"
		exit 1
	fi
}

# before we read the switches, we need to read the config file, if it exists.
read_my_config() {
	local iniFile="$1";
	local section="NONE"
	local sectRegex="^[ \t]*\[[ \t]*([A-Za-z0-1]+)[ \t]*\][ \t]*"
	local varRegex='^[ \t]*([A-Za-z0-9_]*)=("[^\n"]*"|[A-Za-z0-9_]*|[\d]+\.?[\d]*)(?:[ \t]*#.*)?$'
	local comRegex="^[ \t]*#.*$"
	local lineNo=0
	local items=0
	
	if ! [ -e $iniFile ]; then
		echo "ERROR: Config file not found! I need it to work."
		exit 502
	fi
	
	echo Reading Configuration File
	# parse the file
	while IFS='' read -r str
	do
		((lineNo=lineNo + 1))
		if [[ $str =~ $sectDelimiter ]]; then
			$section=${BASH_REMATCH[1]}
		elif [[ $str =~ $varRegex ]]; then
			case "${BASH_REMATCH[1]}" in
				directory) 
					directory=${BASH_REMATCH[2]} 
					((items=items + 1))
					;;
				version)
					if [[ ${BASH_REMATCH[2]} != $version ]]; then
						echo "ERROR: Config Version does not match"
						exit 503
					fi
					((items=items + 1)) ;;
				*) 
					echo "WARNING: Unknown variable on line $lineNo."
			esac
		elif [[ $str =~ $comRegex ]]; then
			continue
		else
			echo "ERROR: Error in config file on line $lineNo."
			exit 504
		fi
	done < $iniFile
	if [ $items -lt 2 ]; then
		echo "ERROR: Not enough required elements"
		exit 505
	fi
}

write_my_config() {
	echo Reading Configuration File
	
}

config_my_config() {
	echo You are now configuring the settings for this
	# two modes: interactive and set a setting. First time run, will want to run it interactively.
}

############################################################
# Generate Certificates (New Command)                      #
############################################################
mkca() {
	# TODO: Alternate directory to store items in. Configure in config file or override with switch.
	# Make the directories that are needed
	# TODO: Test to see if the target is already there. If so, error. Ask for user to delete on their own after checking.
	mkdir $directory/$target
	cd $directory/$target
	mkdir certs crl newcerts private
	chmod 700 private
	touch index.txt
	echo 1000 > serial
	# Generate the config file
	generate_config # uses directory, target, and type variables
	# Generate the private key
	echo Generating CA Private Key
	echo Enter a CA password when prompted. Remember it!
	openssl genrsa -aes256 -out private/$1.key.pem 4096
	chmod 400 private/$1.key.pem
	# Now create the public key
	echo Generating CA Certificate
	openssl req -config openssl.cnf -key private/$1.key.pem -new -x509 -days 3650 -sha512 -extensions v3_ca -out certs/$1.cert.pem
	verify=`openssl x509 -noout -text -in certs/$1.cert.pem`
	echo Please check the certificate
	echo $verify
	# TODO: Verify the certificate is correct automatically
	echo
	echo "Is it OK? [Y/n]"
	read check
	if ! [[ $check == "y" || $check == "Y" || $check == "" ]]
	then
		exit 3
	fi
}

############################################################
# Main Program                                             #
############################################################

# Read the arguments until they are no longer switches
while [ $# -gt 0 ]; do
	case "$1" in
		-t|--type)
			shift
			if [ -z "$(echo $1 |grep ^-.)" ]; then
			type="$1"
			shift
			fi ;;
		-d|--directory)
			# Gives alternate directory than what is in config file
			shift
			if [ -z "$(echo $1 |grep ^-.)" ]; then
			directory="$1"
			shift
			fi ;;
		-h|--help)
			# Equivilent of the help command. In fact, does the same if you double the switch.
			shift
			echo "Came through first case."
			help_funct $1
			exit 0 ;;
		-v|--version)
			echo CA Key Manager version $version
			exit 0 ;;
		-*)    
			echo "${0}: ${1}: invalid option" >&2
			help_main >&2
			exit 2 ;;
		*)    break ;; 
	esac
done
# end of the switches. now for commands
case "$1" in
	list|l)
		echo "Cannot list certificates or CA's" 
		;;
	new|n)
		shift
		# TODO: New ca, user, or server
		echo "Cannot make new certificates yet" 
		;;
	config|c)
		echo "Cannot configure. I don't know how" 
		;;
	help|h)
		shift
		help_funct $1 ;;
	sign|s)
		echo "Sign not implemented" ;;
	export|e|exp)
		echo "Export not implemented" ;;
	import|i|imp)
		echo "Import certificate not implemented" ;;
	*)
		if [[ $1 == "" ]]; then
			echo "No command given. Try the help command"
		else
			echo "Command not found."
		fi
esac
exit 0
# End of the Script
